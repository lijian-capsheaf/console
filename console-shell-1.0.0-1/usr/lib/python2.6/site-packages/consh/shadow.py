import crypt
import os
import getpass

try:
    import pwd
except ImportError:
    pwd = None

import md5crypt
from consh.privilege_manager import drop_privileges_temp, restore_privileges, drop_privileges

SHADOW_PASWORD_FILE = "/etc/shadow"

def get_encrypted_password(username):
    """
    Return the password for the given user name.
    """    
    # /etc/shadow contains the encrypted password information for user's accounts and optional the password aging information.
    # All fields are separated by a ':' symbol. 
    #
    # Fields:
    # 1 - login name                                                
    # 2 - encrypted password                                       
    # 3 - days since Jan 1, 1970 that password was last changed    
    # 4 - days before password may be changed                       
    # 5 - days after which password must be changed                 
    # 6 - days before password is to expire that user is warned     
    # 7 - days after password expires that account is disabled   
    # 8 - days since Jan 1, 1970 that account is disabled          
    # 9 - a reserved field

    f = None
    try:
	drop_privileges_temp("root")
	
        f = open(SHADOW_PASWORD_FILE)

        for line in f:
            fields = line.strip().split(':')
            if fields[0] == username:
                return fields[1]
    except Exception,e:
	print e
        pass
    if f:
        f.close()
	restore_privileges()	

    # Try /etc/passwd file
    if pwd:
        try:
            return pwd.getpwnam(username)[1]
        except KeyError:
            pass
    # Not found
    return "!!"


def authenticate(username, password):
    """
    ... autofunction::: authenticate
        Returns True if the given username and password authenticate again /etc/shadow.
        :param username: the username to authenticate
        :type username: string
        :param password: the password in plain text
        :type password: string
        :return: Returns True if the given username and password authenticate, False otherwise 
        :rtype: boolean
    """ 
    encrypted_password = get_encrypted_password(username)
    if (not encrypted_password or encrypted_password == "!") and not password: # Empty password
        return False
    if "!" in encrypted_password or "*" in encrypted_password: # Locked account
        return False
    
    # The glibc2 version of crypt function supports additional encryption algorithms.
    # If salt is a character string starting with the characters "$id$" followed by
    # a string terminated by "$":
    # 
    #        $id$salt$encrypted
    # 
    # then instead of using the DES machine, id identifies the encryption method
    # used and this then determines how the rest of the password string is
    # interpreted.  The following values of id are supported:
    #        ID  | Method
    #        ---------------------------------------------------------
    #        1   | MD5
    #        2a  | Blowfish (not in mainline glibc; added in some
    #            | Linux distributions)
    #        5   | SHA-256 (since glibc 2.7)
    #        6   | SHA-512 (since glibc 2.7)
    if crypt.crypt(password, encrypted_password) == encrypted_password:
        return True

    if encrypted_password.startswith("$1$"): # MD5 password, if crypt does not work well (e.g. on mac)
        magic, salt = encrypted_password[1:].split('$')[:2]
        magic = '$' + magic + '$'
        return md5crypt.md5crypt(password, salt, magic) == encrypted_password
        
    return False

__all__ = ['authenticate', 'get_encrypted_password']

