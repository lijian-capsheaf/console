#!/usr/bin/python
# -*- coding: utf-8 -*-

# system module
import signal
import os
import subprocess
import sys
import time
import datetime
from readline import get_line_buffer, parse_and_bind, set_completer
import re
import rlcompleter
import traceback

# module byself
import consh.rights as rights
import consh.resolver as resolver
import consh.ansi as ansi
from consh.privilege_manager import restore_privileges

HISTORY_FILENAME =  "/var/consh/.history"
HISTORY_LENGTH =  5000
LOG_FILENAME = "/var/consh/.shell.log"
LOG_LENGTH = 1000
ERROR_FILENAME = "/var/consh/.error"
ERROR_LENGTH = 5000
syscommand = False

config = [
    "HISTORY_FILENAME",
    "HISTORY_LENGTH",
    "LOG_FILENAME",
    "LOG_LENGTH",
    "ERROR_FILENAME",
    "LOG_LENGTH",
    "syscommand"
]

MODULE_FILE = "consh.shell_commands."
SETTING_FILE_PATH = "/var/consh/setting"
EOF = -1


class Shell(object):
    """
 	main for console       
    """
    Prompt = ""
    login_state = False
    username = ""
    stop = False
    start_time = None
    resolver = None
    stdin = None
    interactive = True
    use_rawinput = True
    commands = []
    Timer = {}

    def __init__(self, username = "", right = rights.Rights.ERROR):
        self.ReadConfigFile()
        self.use_rawinput = True
        self.interactive = True

        if rights.has_rights(right):
            self.right = rights.Rights.ERROR
        else:
            self.right = right

        signal.signal(signal.SIGINT, signal.SIG_IGN)    # ctrl + c
        signal.signal(signal.SIGTSTP, signal.SIG_IGN)    # ctrl + z
        
        starttime = time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(time.time()))
        self.write_log(starttime, "start")
        if self.use_rawinput:
            if sys.platform == "darwin":
                parse_and_bind("bind ^I rl_complete")
            else:
                parse_and_bind("tab: complete")
            set_completer(self.completer)
            # readline.set_completer_delims(readline.get_completer_delims().replace("/", ""))
        # login and logout(change username and right)
        self.shell_init(username,right)

        self.mainloop()


    def shell_init(self, username, right = rights.ERROR):
        self.right = right
        self.username = username
        if username != "":
            self.Prompt = ansi.YELLOW + self.username + ansi.RESET + "@" + ansi.GREEN + "console" + ansi.RESET + ": " + ansi.CYAN +" #" +" " + ansi.RESET
        else:
            self.Prompt = ansi.YELLOW + "None" + ansi.RESET + "@" + ansi.GREEN + "console" + ansi.RESET + ": " + ansi.CYAN +" #" +" " + ansi.RESET

        self.resolver = resolver.LocalResolver(self.right)
        self.commands = self.resolver.module_names

        self.start_time = time.time()
        self.starttime = time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(self.start_time))

    # get cmd
    def _exec_cmd(self,line):
        try:
            raw_args = []
            if line == EOF:
                self.exit()
            else:
                raw_args = line.split()
                while "" in raw_args:
                    raw_args.remove("")
                if len(raw_args) == 0:
                    return 
                cmd = raw_args[0]
                raw_args.pop(0)
                if len(raw_args) > 0:
                    line = raw_args
                else:
                    line = []
                self.func(cmd,line)
        except:
            pass


    # commands interface
    def func(self, cmd, raw_args = []):
        try:
            func_n = self.resolver.has_command(cmd)
            # import and get module
            if func_n == None:
                if syscommand:
                    cmd_s = cmd + " " + " ".join(raw_args)
                    os.system(cmd_s)
                else:    
                    self.write(ansi.MAGENTA + "%s: command not found" % cmd + ansi.RESET)
            else:
                # import module while module has exist reload module
                if not (MODULE_FILE + func_n in sys.modules.keys()):
                    __import__(MODULE_FILE + func_n)
                    module = sys.modules[MODULE_FILE + func_n]
                else:
		            module = sys.modules[MODULE_FILE + func_n]
		            reload(module)

                function = getattr(module, func_n)
                function(cmd, context = self, *raw_args)
                restore_privileges()
                historys = raw_args
                historys.insert(0,cmd)
                self.write_history(historys)
                return

        except Exception, ex:
            self.write(ansi.RED + str(ex) + ansi.RESET)
            msg = traceback.format_exc()
            self.error(msg)
    
    #  subcommands interface 
    def func_next(self, cmd, cmd_next, cmd_sur):
        cmd_n = self.resolver.has_command(cmd_next, cmd)
        if cmd_n != None:
            if cmd_n != "":
                cmds = cmd.split()
                cmdn = "_".join(cmds)
                modulename = cmdn + "_" + cmd_n
                if not (MODULE_FILE + modulename in sys.modules.keys()):
		            __import__(MODULE_FILE + modulename)
		            module = self.resolver.get_module(modulename)
                else:
		            module = self.resolver.get_module(modulename)
		            reload(module)
                func_n = getattr(module,modulename)
                func_n(cmd + " " + cmd_n, *cmd_sur, context = self)
            else:
                self.write("%s" % cmd_next)
        else:
            self.write("%s%s:%s:Unknow param%s"% (ansi.RED,cmd, cmd_next,ansi.RESET))
            return 


    def exit(self):
        """
            exit this shell,not use exit handler
            get some infomation about exit and write log file
        """
        self.stop = True
        end_time = time.time()
        online_time = end_time - self.start_time
        hour = time.localtime().tm_hour
        self.write("your online time is: %s" % self.time_interval(end_time, self.start_time))
        endtime = time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(end_time))
        self.write_log(endtime,"exit")

    def time_interval(self, time1, time2):
        """
            return string about interval,like XX days XX hours XX minites XX second
        """
        time_s = time1 - time2
        min_s = 60
        hour_s = 60 * min_s
        day_s = 24 * hour_s

        day_n = int(time_s / day_s)
        time_s = time_s - day_n * day_s
        hour_n = int(time_s / hour_s)
        time_s = time_s - hour_n * hour_s
        min_n = int(time_s /min_s)
        time_s = time_s - min_n * min_s
        sec_n = int(round(time_s))
        time_str = ansi.GREEN + str(day_n) + ansi.RED + "days " + ansi.BLUE + str(hour_n) + ansi.YELLOW + "hours " + ansi.YELLOW + str(min_n) + ansi.BLUE + "minites " + ansi.RED + str(sec_n) + ansi.GREEN + "seconds" + ansi.RESET
        return time_str

    # read config info about var contain config
    def ReadConfigFile(self, FilePath = SETTING_FILE_PATH):
        if not os.path.exists(FilePath):
            try:
                paths = FilePath.split("/")
                filename = paths[-1]
                paths.pop()
                path = "/".join(paths)
                if not os.path.exists(path):
                    os.makedirs(path)
                os.mknod(FilePath)
                return
            except:
                msg = traceback.format_exc()
                self.error(msg)
                return
        f = open(FilePath,"rb")
        settings = f.readlines()
        for setting in settings:
            if "=" in setting:
                setting = setting.strip("\n")
                s_key = setting.split("=")[0].strip()
                s_value = setting.split("=")[1].strip()
                for s_key in config:
                    try:
                        locals()[s_key] = (type(s_key))(s_value)
                    except Exception,e:
                        msg = traceback.format_exc()
                        self.error(msg)
                        continue


    # write history command
    def write_history(self, history_cmd):
        """
            write history cmmands to history file
            and while history commands more than limit,
            delete older history commands
        """
        fhistoryw = None
        # if no length, don't write history
        if HISTORY_LENGTH == 0:
            return
        if not os.path.exists(HISTORY_FILENAME):
            try:
                paths = HISTORY_FILENAME.split("/")
                filename = paths[-1]
                paths.pop()
                path = "/".join(paths)
                if not os.path.exists(path):
                    os.makedirs(path)
                os.mknod(HISTORY_FILENAME)
            except:
                msg = traceback.format_exc()
                self.error(msg)
                return
        try:
            time_now = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time()))
            fhistoryw = file(HISTORY_FILENAME, "ab")

            # write history command
            fhistoryw.write(time_now)
            fhistoryw.write("-> ")
            his_cmd = " ".join(history_cmd)
            fhistoryw.write(his_cmd)
            fhistoryw.write("\n")
            fhistoryw.close()

            # Be sure the number of history commands not more than toplimit
            if HISTORY_LENGTH > 0:
                try:
                    fhistoryr = file(HISTORY_FILENAME, "rb+")
                    lines = fhistoryr.readlines()
                    excess = len(lines) - HISTORY_LENGTH
                    while excess > 0:
                        lines.pop(0)
                        excess = excess -1
                    fhistoryr.close()    
                except:
                    fhistoryr.close()
                    msg = traceback.format_exc()
                    self.error(msg)
                try:
                    fhistoryww = file(HISTORY_FILENAME, "wb+")
                    fhistoryww.writelines(lines)
                    fhistoryww.close()
                except:
                    fhistoryww.close()
                    msg = traceback.format_exc()
                    self.error(msg)
		    return
        except Exception,e:
            msg = traceback.format_exc()
            self.error(msg)
            return

	    if fhistoryw:
		    fhistoryw.close()
            self.write("history cmd write error")
    

    def write_log(self, time, msg = ""):
        """
        """
        flogw = None
        if LOG_LENGTH == 0:
            return
        if not os.path.exists(LOG_FILENAME):
            try:
                paths = HISTORY_FILENAME.split("/")
                filename = paths[-1]
                paths.pop()
                path = "/".join(paths)
                if not os.path.exists(path):
                    os.makedirs(path)
                os.mknod(LOG_FILENAME)
            except:
                msg = traceback.format_exc()
                self.error(msg)
                return

        try:
            flogw = file(LOG_FILENAME, "ab")
            if self.username == "":
                user = "None"
            else:
                user = self.username
                flogw.write("%s %s at %s" %(user,msg,time))
                flogw.write("\n")
                flogw.close()
            if LOG_LENGTH > 0:
                try:
                    flogr = file(LOG_FILENAME, "rb+")
                    lines = flogr.readlines()
                    excess = len(lines) - LOG_LENGTH
                    while excess > 0:
                        lines.pop(0)
                    excess = excess -1
                    flogr.close
                except:
                    flogr.close()
                    msg = traceback.format_exc()
                    self.error(msg)
                    return
                try:
                    flogww = file(LOG_FILENAME, "wb+")
                    flogww.writelines(lines)
                    flogww.close()
                except:
                    flogww.close()
                    msg = traceback.format_exc()
                    self.error(msg)
                    return
            return
        except Exception,e:
            msg = traceback.format_exc()
            self.error(msg)
            return

        if flogw:
            flogw.close()
            self.write("write log error")

    def error(self, msg = traceback.format_exc()):
	"""
	    msg's default value is tracback.format_exc()
        
        format example:
        # ERROR #
        2018.02.12 12:10:58 admin
        xxxxxxxxxxxxxxxxxxx
        xxxxxxxxxx error xxxxxxxxxx
        xxxxxxxxxxxxxxxxxxxxxxxxxx
	"""
        title = "# ERROR #"
        ferrorw = None
        if ERROR_LENGTH == 0:
            return
        if not os.path.exists(HISTORY_FILENAME):
            try:
                paths = HISTORY_FILENAME.split("/")
                filename = paths[-1]
                paths.pop()
                path = "/".join(paths)
                if not os.path.exists(path):
                    os.makedirs(path)
                os.mknod(HISTORY_FILENAME)
            except Exception,e:
                self.write("something error happend in error(handle)")
        try:
            if self.username == "":
                user = "None"
            else:
                user = self.username
                time_err = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time()))
       	        ferrorw = file(ERROR_FILENAME, "ab")
                ferrorw.write("%s\n%s %s\n%s\n"%(title, time_err, user, msg))
            if ERROR_LENGTH > 0:
                try:
                    ferrorr = file(ERROR_FILENAME, "rb+")
                    lines = ferrorr.read().split(title)
                    excess = len(lines) - ERROR_LENGTH - 1
                    while excess > 0:
			            lines.pop(0)
                    excess = excess -1
                except:
                    ferrorr.close()
                    msg = traceback.format_exc()
                    self.error(msg)
                    return
                try:
                    lines.insert(0,"")
                    lists = title.join(lines)
                    ferrorww = file(ERROR_FILENAME, "wb+")
                    ferrorww.writelines(lists)
                except:
                    ferrorww.close()
                    msg = traceback.format_exc()
                    self.error(msg)
                    return
            return
        except:
            ferrorw.close()
            msg = traceback.format_exc()
            self.error(msg)
            return

    def write(self, msg = "", *args,  **argv):
        if args:
            msg = msg % args
        sys.stdout.write(msg)
        sys.stdout.flush()
        if not argv.get("ban_newline", False):
            sys.stdout.write("\n")
            sys.stdout.flush()

    def read(self , prompt = ""):
	    # sys.stdin.flush()
	    in_put = raw_input(prompt).strip("\r\n")
	    sys.stdout.flush()
	    # sys.stdin.flush()
	    return in_put


    def mainloop(self):
        
        while not self.stop:
            try:
                self._exec_cmd(self.read_args(interactive = self.interactive))
            except:
                msg = traceback.format_exc()
                self.error(msg)



    # read args(list)
    def read_args(self, prompt = None, interactive = True, dont_use_readline = False):
        if not interactive:
            line = sys.stdin.readline().strip("\r\n").strip("\n")
            if len(line):
                return line[:-1]
            else:
                return EOF
        else:
            if not prompt:
                pass
            if self.use_rawinput and not dont_use_readline:
                try:
		            line = self.read(self.Prompt).strip()
		            return line
                except EOFError:
                    msg = traceback.format_exc()
                    self.error(msg)
                    return EOF
            else:
                sys.stdout.write(self.Prompt)
                sys.stdout.flush()
                line = sys.stdin.readline().strip("\r\n").strip("\n")
                if len(line):
                    return line[:-1]
                else:
                    return EOF
                   
    
    def completer(self, text, state):
        try:
            self.completion_matches = []
            text_u = get_line_buffer().lstrip()
            if text_u ==  "" or text_u == "help ":
                self.completion_matches = self.resolver.get_commands()
            else:
                if text_u[len(text_u) - 1] == " ":
                    lines = text_u.split()
                    while "" in lines:
                        lines.remove("")
                    text_u = " ".join(lines)
                    self.completion_matches = self.resolver.get_commands(text_u)

                else:
                    lines = text_u.split()
                    while "" in lines:
                        lines.remove("")
                    if len(lines) == 1:
                        commands = self.resolver.get_commands()
                        cmds = [cmd for cmd in commands if cmd.startswith(lines[0])]
                        if len(cmds) == 1 and cmds[0] == lines[0]:
                            self.completion_matches.append(text_u +  " ")
                        else:
                            self.completion_matches = cmds
                    if len(lines) > 1:
                        args = lines[len(lines) - 1]
                        lines.pop()
                        line = " ".join(lines)
                        commands = self.resolver.get_commands(line)
                        cmds = [cmd for cmd in commands if cmd.startswith(args)]
                        if len(cmds) == 1 and cmds[0] == args:
                            self.completion_matches.append(args + " ")
                        else:
                            self.completion_matches = cmds
            if state < len(self.completion_matches):
                return self.completion_matches[state]
            else:
                return None
        except:
            msg = traceback.format_exc()
            self.error(msg)
            return None
	# get doc from module
    def get_doc(self, cmd, line = ""):
        
        def info(cmd):
            modulename = self.resolver.get_realcmd(cmd)
            if modulename == "":
                return None
            cmds = modulename.split()
            while "" in cmds:
                cmds.remove("")
            modulename = "_".join(cmds)
            module = self.resolver.get_module(modulename)
            if module == None:
                return None
            helpinfo = self.resolver.get_func_doc(getattr(module, modulename))
            return helpinfo
        
        if line == "":
            return info(cmd)
        elif line in ["note", "format", "description"]:
            return info(cmd)[line]
        else:
            self.write("no infomations about %s"% line)
            return ""

def main():
    shell = Shell()
    

if __name__ == "__main__":
    main()
